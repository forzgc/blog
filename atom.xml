<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>川的小屋</title>
  
  
  <link href="https://blog.forzgc.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.forzgc.cn/"/>
  <updated>2022-01-21T11:37:53.995Z</updated>
  <id>https://blog.forzgc.cn/</id>
  
  <author>
    <name>chuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React</title>
    <link href="https://blog.forzgc.cn/2022/01/15/React/"/>
    <id>https://blog.forzgc.cn/2022/01/15/React/</id>
    <published>2022-01-15T09:29:02.000Z</published>
    <updated>2022-01-21T11:37:53.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul><li>绑定事件名为驼峰写法，例如：onClick</li><li>使用 {} 绑定处理函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></li></ul><p>使用e.preventDefault()阻止事件默认行为，不能再使用 (return false) 的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Form() &#123;</span><br><span class="line">  function handleSubmit(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&#x27;You clicked submit.&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;handleSubmit&#125;&gt;</span><br><span class="line">      &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：此e和原生的事件不同</p><p>Class形式的Component<br>如果事件处理函数中需要使用组件实例，那么需要在Constructor中用bind()为事件处理函数绑定上下文this</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">    // This binding is necessary to make `this` work in the callback</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>也可使用另外两种方式代替：<a href="https://reactjs.org/docs/handling-events.html">https://reactjs.org/docs/handling-events.html</a></p><p>绑定事件自定义传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ol><li>在js部分使用 if…else if…else语法 条件使用jsx表达式</li><li>在jsx表达式{}中使用 &amp;&amp; 或者 三元运算符</li><li>render()函数返回null可以让组件自身不被渲染出来，但是组件生命周期仍会运行</li></ol><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件绑定&quot;&gt;&lt;a href=&quot;#事件绑定&quot; class=&quot;headerlink&quot; title=&quot;事件绑定&quot;&gt;&lt;/a&gt;事件绑定&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;绑定事件名为驼峰写法，例如：onClick&lt;/li&gt;
&lt;li&gt;使用 {} 绑定处理函数&lt;figure class</summary>
      
    
    
    
    
    <category term="react" scheme="https://blog.forzgc.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Phicomm N1 安装 Arch Linux Arm</title>
    <link href="https://blog.forzgc.cn/2021/10/18/Phicomm-N1-%E5%AE%89%E8%A3%85-Arch-Linux-Arm/"/>
    <id>https://blog.forzgc.cn/2021/10/18/Phicomm-N1-%E5%AE%89%E8%A3%85-Arch-Linux-Arm/</id>
    <published>2021-10-18T13:04:06.000Z</published>
    <updated>2022-01-08T04:02:40.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看硬盘"><a href="#1-查看硬盘" class="headerlink" title="1.查看硬盘"></a>1.查看硬盘</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><h2 id="2-parted-硬盘分区"><a href="#2-parted-硬盘分区" class="headerlink" title="2.parted 硬盘分区"></a>2.parted 硬盘分区</h2><p>安装到emmc选择 mmcblk1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEV_EMMC=/dev/mmcblk1</span><br><span class="line">parted -s &quot;$&#123;DEV_EMMC&#125;&quot; mklabel msdos</span><br><span class="line">parted -s &quot;$&#123;DEV_EMMC&#125;&quot; mkpart primary fat32 700M 1024M</span><br><span class="line">parted -s &quot;$&#123;DEV_EMMC&#125;&quot; mkpart primary ext4 1024M 100%</span><br><span class="line">DEV_BOOT=/dev/mmcblk1p1</span><br><span class="line">DEV_ROOT=/dev/mmcblk1p2</span><br></pre></td></tr></table></figure><p>安装到u盘选择 sda</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEV_U=/dev/sda</span><br><span class="line">parted -s &quot;$&#123;DEV_U&#125;&quot; mklabel msdos</span><br><span class="line">parted -s &quot;$&#123;DEV_U&#125;&quot; mkpart primary fat32 0 256M</span><br><span class="line">parted -s &quot;$&#123;DEV_U&#125;&quot; mkpart primary ext4 256M 100%</span><br><span class="line">DEV_BOOT=/dev/sda1</span><br><span class="line">DEV_ROOT=/dev/sda2</span><br></pre></td></tr></table></figure><h2 id="3-格式化分区"><a href="#3-格式化分区" class="headerlink" title="3.格式化分区"></a>3.格式化分区</h2><p>emmc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfs.vfat -F 32 -n EMMC_BOOT &quot;$&#123;DEV_BOOT&#125;&quot;</span><br><span class="line">mkfs.ext4 -L EMMC_ROOT &quot;$&#123;DEV_ROOT&#125;&quot;</span><br></pre></td></tr></table></figure><p>u盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfs.vfat -F 32 -n BOOT &quot;$&#123;DEV_BOOT&#125;&quot;</span><br><span class="line">mkfs.ext4 -L ROOT &quot;$&#123;DEV_ROOT&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="4-挂载分区"><a href="#4-挂载分区" class="headerlink" title="4.挂载分区"></a>4.挂载分区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount &quot;$&#123;DEV_ROOT&#125;&quot; /mnt</span><br><span class="line">mkdir -p /mnt/boot</span><br><span class="line">mount &quot;$&#123;DEV_BOOT&#125;&quot; /mnt/boot</span><br></pre></td></tr></table></figure><h2 id="5-下载安装-Arch-Linux"><a href="#5-下载安装-Arch-Linux" class="headerlink" title="5.下载安装 Arch Linux"></a>5.下载安装 Arch Linux</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp &amp;&amp; curl -OL https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/os/ArchLinuxARM-aarch64-latest.tar.gz</span><br></pre></td></tr></table></figure><h2 id="6-解压到硬盘"><a href="#6-解压到硬盘" class="headerlink" title="6.解压到硬盘"></a>6.解压到硬盘</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsdtar -xpvf ArchLinuxARM-aarch64-latest.tar.gz -C /mnt/</span><br></pre></td></tr></table></figure><h2 id="7-处理DNS"><a href="#7-处理DNS" class="headerlink" title="7.处理DNS"></a>7.处理DNS</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlink /mnt/etc/resolv.conf</span><br><span class="line">cat /etc/resolv.conf | tee /mnt/etc/resolv.conf</span><br></pre></td></tr></table></figure><h2 id="8-chroot到新系统"><a href="#8-chroot到新系统" class="headerlink" title="8.chroot到新系统"></a>8.chroot到新系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /mnt</span><br><span class="line">mount -t proc /proc proc</span><br><span class="line">mount --make-rslave --rbind /sys sys</span><br><span class="line">mount --make-rslave --rbind /dev dev</span><br><span class="line">mount --make-rslave --rbind /run run</span><br><span class="line">cd /</span><br><span class="line">chroot /mnt /bin/bash</span><br><span class="line"></span><br><span class="line"># 加载profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="9-系统设置"><a href="#9-系统设置" class="headerlink" title="9.系统设置"></a>9.系统设置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 设置locale</span><br><span class="line">echo &#x27;en_US.UTF-8 UTF-8&#x27; &gt;&gt; /etc/locale.gen</span><br><span class="line">locale-gen</span><br><span class="line"></span><br><span class="line"># 允许ssh root用户登录</span><br><span class="line">echo &#x27;PermitRootLogin yes&#x27; &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"># 设置密码</span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line"># 设置网卡地址</span><br><span class="line">text=n1bc # 可以替换成任意字符</span><br><span class="line">macaddr=$(echo $text | md5sum | sed &#x27;s/^\(..\)\(..\)\(..\)\(..\)\(..\).*$/02:\1:\2:\3:\4:\5/&#x27;)</span><br><span class="line">echo &quot;[Link]&quot; &gt;&gt; /etc/systemd/network/eth.network</span><br><span class="line">echo &quot;MACAddress=$&#123;macaddr&#125;&quot; &gt;&gt; /etc/systemd/network/eth.network</span><br><span class="line">unset text macaddr</span><br><span class="line"></span><br><span class="line"># 设置主机名称</span><br><span class="line">nano /etc/hostname</span><br><span class="line"></span><br><span class="line"># 初始化 pacman</span><br><span class="line">pacman-key --init</span><br><span class="line">pacman-key --populate archlinuxarm</span><br><span class="line"></span><br><span class="line"># 修改软件源</span><br><span class="line">nano /etc/pacman.d/mirrorlist</span><br><span class="line"># 在最前面添加</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxarm/$arch/$repo</span><br><span class="line"></span><br><span class="line"># 设置 fstab</span><br><span class="line">lsblk -f # 查看uuid</span><br><span class="line">UUID_ROOT=root分区uuid</span><br><span class="line">UUID_BOOT=boot分区uuid</span><br><span class="line">echo &quot;UUID=$&#123;UUID_ROOT&#125; / ext4 rw,relatime 0 1&quot; &gt;&gt; /etc/fstab</span><br><span class="line">echo &quot;UUID=$&#123;UUID_BOOT&#125; /boot vfat rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro 0 2&quot; &gt;&gt; /etc/fstab</span><br><span class="line">unset UUID_ROOT UUID_BOOT</span><br></pre></td></tr></table></figure><h2 id="10-编译内核（交叉编译）"><a href="#10-编译内核（交叉编译）" class="headerlink" title="10.编译内核（交叉编译）"></a>10.编译内核（交叉编译）</h2><h3 id="下载-交叉编译工具链"><a href="#下载-交叉编译工具链" class="headerlink" title="下载 交叉编译工具链"></a>下载 交叉编译工具链</h3><p><a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads">https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads</a></p><p>win 选择<br>Windows (mingw-w64-i686) hosted cross compilers -&gt;<br>AArch64 GNU/Linux target (aarch64-none-linux-gnu) -&gt;<br>gcc-arm-10.3-2021.07-mingw-w64-i686-aarch64-none-linux-gnu.tar.xz</p><p>linux 选择<br>x86_64 Linux hosted cross compilers -&gt;<br>AArch64 GNU/Linux target (aarch64-none-linux-gnu) -&gt;<br>gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz</p><p>下载后解压设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">xz -d gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz</span><br><span class="line">tar -xvf gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar</span><br><span class="line">export PATH=解压路径/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="下载-Linux-Kernel"><a href="#下载-Linux-Kernel" class="headerlink" title="下载 Linux Kernel"></a>下载 Linux Kernel</h3><p><a href="https://www.kernel.org/">https://www.kernel.org</a></p><p>解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">xz -d linux-5.14.13.tar.xz</span><br><span class="line">tar -xvf linux-5.14.13.tar</span><br></pre></td></tr></table></figure><h3 id="获取-Phicomm-N1的-补丁文件"><a href="#获取-Phicomm-N1的-补丁文件" class="headerlink" title="获取 Phicomm N1的 补丁文件"></a>获取 Phicomm N1的 补丁文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone https://aur.archlinux.org/linux-phicomm-n1.git</span><br></pre></td></tr></table></figure><h3 id="交叉编译设置"><a href="#交叉编译设置" class="headerlink" title="交叉编译设置"></a>交叉编译设置</h3><p>复制 补丁文件 中 config 文件到 Linux Kernel 文件夹 重命名 .config</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ～/linux-5.14.13</span><br><span class="line">cat ～/linux-phicomm-n1/config &gt; ./.config</span><br></pre></td></tr></table></figure><h3 id="打补丁-amp-替换dts"><a href="#打补丁-amp-替换dts" class="headerlink" title="打补丁&amp;替换dts"></a>打补丁&amp;替换dts</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ～/linux-5.14.13</span><br><span class="line">patch -p1 -i &quot;$&#123;srcdir&#125;/01-aegis-crypto-gcc10.patch&quot;</span><br><span class="line">patch -p1 &lt; &quot;$&#123;srcdir&#125;/02-revert-TEXT_OFFSET-deletion.patch&quot;</span><br><span class="line">patch -p1 &lt; &quot;$&#123;srcdir&#125;/03-make-proc-cpuinfo-consistent-on-arm64-and-arm.patch&quot;</span><br><span class="line">cat &quot;$&#123;srcdir&#125;/$&#123;target_dts&#125;&quot; &gt; &quot;./arch/arm64/boot/dts/amlogic/$&#123;target_dts&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64</span><br><span class="line">make -j16 LOCALVERSION=&quot;-n1bc&quot; targz-pkg</span><br></pre></td></tr></table></figure><h3 id="生成-initramfs-img"><a href="#生成-initramfs-img" class="headerlink" title="生成 initramfs.img"></a>生成 initramfs.img</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkinitcpio -p xxx</span><br></pre></td></tr></table></figure><h3 id="生成-uInitrd"><a href="#生成-uInitrd" class="headerlink" title="生成 uInitrd"></a>生成 uInitrd</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkimage -A arm64 -O linux -T ramdisk -C gzip -n uInitrd -d /boot/initramfs-linux.img /boot/uInitrd</span><br><span class="line">mkimage -A arm64 -O linux -T ramdisk -C gzip -n uInitrd -d /mnt/boot/initramfs-linux.img /mnt/boot/uInitrd</span><br></pre></td></tr></table></figure><h3 id="生成-autoscript"><a href="#生成-autoscript" class="headerlink" title="生成 autoscript"></a>生成 autoscript</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkimage -A arm -T script -C none -d /mnt/boot/emmc_autoscript.cmd /mnt/boot/emmc_autoscript</span><br></pre></td></tr></table></figure><h3 id="重启后设置"><a href="#重启后设置" class="headerlink" title="重启后设置"></a>重启后设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 设置时区</span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># 删除默认用户</span><br><span class="line">userdel -rf alarm</span><br><span class="line"></span><br><span class="line"># 添加用户并修改密码</span><br><span class="line">useradd -m -G wheel username</span><br><span class="line">passwd username</span><br><span class="line"></span><br><span class="line"># 更新系统</span><br><span class="line">pacman -Syu</span><br><span class="line"></span><br><span class="line"># 安装常用应用</span><br><span class="line">pacman -S base-devel vim git</span><br><span class="line"></span><br><span class="line"># 为wheel用户组添加sudo权限</span><br><span class="line">vim /etc/sudoers # 删除 %wheel ALL=(ALL) ALL 前面的注释</span><br><span class="line"></span><br><span class="line"># 删除ssh root登录权限</span><br><span class="line">vim /etc/ssh/sshd_config # 删除 PermitRootLogin yes 那一行</span><br></pre></td></tr></table></figure><h3 id="需要软件"><a href="#需要软件" class="headerlink" title="需要软件"></a>需要软件</h3><p>mkfs.vfat    dosfstools<br>mkimage      uboot-tools<br>lsusb        usbutils</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-查看硬盘&quot;&gt;&lt;a href=&quot;#1-查看硬盘&quot; class=&quot;headerlink&quot; title=&quot;1.查看硬盘&quot;&gt;&lt;/a&gt;1.查看硬盘&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-Class</title>
    <link href="https://blog.forzgc.cn/2021/09/11/Java-Class/"/>
    <id>https://blog.forzgc.cn/2021/09/11/Java-Class/</id>
    <published>2021-09-10T16:13:26.000Z</published>
    <updated>2021-11-01T15:18:53.681Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zyly/p/10727511.html">https://www.cnblogs.com/zyly/p/10727511.html</a></p><h2 id="反射包-Reflect"><a href="#反射包-Reflect" class="headerlink" title="反射包 Reflect"></a>反射包 Reflect</h2><p>使用反射包 可生成 Class对象 中的 Constructor Field Method 等类的对象</p><h2 id="代理-Proxy-newProxyInstance"><a href="#代理-Proxy-newProxyInstance" class="headerlink" title="代理 Proxy.newProxyInstance"></a>代理 Proxy.newProxyInstance</h2><p>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</p><ul><li>loader：选用的类加载器。因为代理的是zack，所以一般都会用加载zack的类加载器；</li><li>interfaces：被代理的类所实现的接口，这个接口可以是多个；</li><li>h：绑定代理类的一个方法，或者是InvacationHandler接口的一个实现；</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>可用 () -&gt; {} 格式生成实现指定接口的内部类</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zyly/p/10727511.html&quot;&gt;https://www.cnblogs.com/zyly/p/10727511.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;反射包-Reflect&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-注解</title>
    <link href="https://blog.forzgc.cn/2021/09/10/Java-%E6%B3%A8%E8%A7%A3/"/>
    <id>https://blog.forzgc.cn/2021/09/10/Java-%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-09-10T14:14:17.000Z</published>
    <updated>2021-11-05T01:16:31.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public @interface TestAnnotation&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public @interface TestAnnotation&#123;</span><br><span class="line">  int id();</span><br><span class="line">  String msg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public @interface TestAnnotation&#123;</span><br><span class="line">  int id();</span><br><span class="line">  String msg() default &quot;error&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元注解-用于自定义注解"><a href="#元注解-用于自定义注解" class="headerlink" title="元注解 用于自定义注解"></a>元注解 用于自定义注解</h2><ol><li>@Retention 注解的存活时间</li><li>@Documented 将注解中的元素包含到 Javadoc 中去</li><li>@Target 指定了注解运用的地方</li><li>@Inherited 如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解</li><li>@Repeatable 注解的值可以同时取多个</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-枚举</title>
    <link href="https://blog.forzgc.cn/2021/09/05/Java-%E6%9E%9A%E4%B8%BE/"/>
    <id>https://blog.forzgc.cn/2021/09/05/Java-%E6%9E%9A%E4%B8%BE/</id>
    <published>2021-09-05T09:28:50.000Z</published>
    <updated>2021-10-03T15:26:22.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么枚举类的定义如下"><a href="#为什么枚举类的定义如下" class="headerlink" title="为什么枚举类的定义如下"></a>为什么枚举类的定义如下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;</span><br></pre></td></tr></table></figure><p>这个的意思是：Enum的泛型类型实参只能是继承Enum的子类，并且要求子类只能从Enum继承自己类型的方法（compareTo等）</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Color&#123;</span><br><span class="line">  RED,BLUE,GREEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="迭代枚举类"><a href="#迭代枚举类" class="headerlink" title="迭代枚举类"></a>迭代枚举类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(ColorEnum colorEnum : ColorEnum.values())&#123;</span><br><span class="line">    System.out.println(colorEnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch中使用枚举类"><a href="#switch中使用枚举类" class="headerlink" title="switch中使用枚举类"></a>switch中使用枚举类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ColorEnum colorEnum = ColorEnum.BLUE;</span><br><span class="line">switch (colorEnum)&#123;</span><br><span class="line">    case RED -&gt; System.out.println(&quot;红色&quot;);</span><br><span class="line">    case BLUE -&gt; System.out.println(&quot;蓝色&quot;);</span><br><span class="line">    case GREEN -&gt; System.out.println(&quot;绿色&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类的静态方法"><a href="#枚举类的静态方法" class="headerlink" title="枚举类的静态方法"></a>枚举类的静态方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回指定字符串值的枚举常量</span><br><span class="line">ColorEnum.valueOf(&quot;BLUE&quot;)</span><br><span class="line">// 返回枚举类所有的枚举常量</span><br><span class="line">ColorEnum.values()</span><br></pre></td></tr></table></figure><h2 id="枚举对象的方法"><a href="#枚举对象的方法" class="headerlink" title="枚举对象的方法"></a>枚举对象的方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回当前枚举对象在枚举类中的索引</span><br><span class="line">ColorEnum.BLUE.ordinal();</span><br><span class="line">// 返回当前枚举对象的字符串名称</span><br><span class="line">ColorEnum.BLUE.name();</span><br></pre></td></tr></table></figure><h2 id="为枚举对象添加自定义属性"><a href="#为枚举对象添加自定义属性" class="headerlink" title="为枚举对象添加自定义属性"></a>为枚举对象添加自定义属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public enum Color&#123;</span><br><span class="line">  RED(1,&quot;红色&quot;),BLUE(2,&quot;蓝色&quot;),GREEN(3,&quot;绿色&quot;);</span><br><span class="line">  private int code;</span><br><span class="line">  private String desc;</span><br><span class="line">  Color(int code,String desc)&#123;</span><br><span class="line">    this.code = code;</span><br><span class="line">    this.desc = desc;</span><br><span class="line">  &#125;;</span><br><span class="line">  public int getCode()&#123;</span><br><span class="line">    return code;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么枚举类的定义如下&quot;&gt;&lt;a href=&quot;#为什么枚举类的定义如下&quot; class=&quot;headerlink&quot; title=&quot;为什么枚举类的定义如下&quot;&gt;&lt;/a&gt;为什么枚举类的定义如下&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public abstract class Enum&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个的意思是：Enum的泛型类型实参只能是继承Enum的子类，并且要求子类只能从Enum继承自己类型的方法（compareTo等）&lt;/p&gt;
&lt;h2 id=&quot;枚举类&quot;&gt;&lt;a href=&quot;#枚举类&quot; class=&quot;headerlink&quot; title=&quot;枚举类&quot;&gt;&lt;/a&gt;枚举类&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public enum Color&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  RED,BLUE,GREEN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-Servlet</title>
    <link href="https://blog.forzgc.cn/2021/09/05/Java-Servlet/"/>
    <id>https://blog.forzgc.cn/2021/09/05/Java-Servlet/</id>
    <published>2021-09-05T03:10:20.000Z</published>
    <updated>2021-10-03T15:26:22.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Tomcat是Setvlet应用的运行容器<br>下载链接：<a href="https://tomcat.apache.org/">https://tomcat.apache.org</a></p><span id="more"></span><h2 id="使用Servlet-API新建应用"><a href="#使用Servlet-API新建应用" class="headerlink" title="使用Servlet API新建应用"></a>使用Servlet API新建应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import jakarta.servlet.ServletException;</span><br><span class="line">import jakarta.servlet.http.HttpServlet;</span><br><span class="line">import jakarta.servlet.http.HttpServletRequest;</span><br><span class="line">import jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(&quot;text/html&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line">        out.println(&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;head&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;meta charset=\&quot;UTF-8\&quot; /&gt;&quot;);</span><br><span class="line">        String title = &quot;Hello&quot;;</span><br><span class="line">        out.println(&quot;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;/head&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;body&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;/body&gt;&quot;);</span><br><span class="line">        out.println(&quot;&lt;/html&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置应用"><a href="#配置应用" class="headerlink" title="配置应用"></a>配置应用</h2><ol><li>在 tomcat 目录下的 webapps 目录新建文件夹 my-app</li><li>在 my-app 目录下新建 WEB-INF 目录</li><li>在 WEB-INF 目录下新建文件 web.xml 与 目录 classes</li><li>代码将上面编译后的字节码复制到 classes 目录</li><li>配置web.xml<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee</span><br><span class="line">                      https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span><br><span class="line">  version=&quot;5.0&quot;</span><br><span class="line">  metadata-complete=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 显示名称 --&gt;</span><br><span class="line">  &lt;display-name&gt;MyApp&lt;/display-name&gt;</span><br><span class="line">  &lt;!-- 描述 --&gt;</span><br><span class="line">  &lt;description&gt;</span><br><span class="line">   一个简单的servlet</span><br><span class="line">  &lt;/description&gt;</span><br><span class="line"></span><br><span class="line">  &lt;request-character-encoding&gt;UTF-8&lt;/request-character-encoding&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- servlet配置 --&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;!-- servlet名称 --&gt;</span><br><span class="line">    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- servlet class（classes目录下） 路径 --&gt;</span><br><span class="line">    &lt;servlet-class&gt;MyServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-name&gt;paramName1&lt;/param-name&gt;</span><br><span class="line">      &lt;param-value&gt;paramValue1&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;!-- 路径映射 --&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;!-- 与上面servlet-name一致 --&gt;</span><br><span class="line">    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;</span><br><span class="line">      &lt;!-- 路径 --&gt;</span><br><span class="line">      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li><li>运行tomcat<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/startup.sh 或者 ./bin/catalina.sh run/start/stop</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Tomcat&quot;&gt;&lt;a href=&quot;#Tomcat&quot; class=&quot;headerlink&quot; title=&quot;Tomcat&quot;&gt;&lt;/a&gt;Tomcat&lt;/h2&gt;&lt;p&gt;Tomcat是Setvlet应用的运行容器&lt;br&gt;下载链接：&lt;a href=&quot;https://tomcat.apache.org/&quot;&gt;https://tomcat.apache.org&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-线程通信</title>
    <link href="https://blog.forzgc.cn/2021/09/03/Java-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>https://blog.forzgc.cn/2021/09/03/Java-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2021-09-03T14:05:21.000Z</published>
    <updated>2021-10-03T15:26:22.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>使用 synchronized(obj){} 包住的代码块称为同步代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj)&#123;</span><br><span class="line">  代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>同步锁可以解决多个线程对共享资源的竞争</p><ul><li>每个Java对象都有且只有一个同步锁，这只是一种概念，也可以称以一个对象为标记的锁。</li><li>在任何时候，最多只有一个线程拥有特定对象的锁</li><li>当线程需要执行同步代码块synchronized(obj){}标记的代码时，必须获得obj变量所引用对象的锁。</li><li>没有获得锁的线程会被放入同步代码块obj的锁池中，这个线程会进入阻塞状态。</li><li>当持有同步锁的线程释放了锁后，Java虚拟机会随机从obj的锁池中选一个线程，使这个线程拥有同步锁，这个线程进入就绪状态。</li><li>假如一个线程需要的锁没有被其他线程占用，那么这个线程就自动拥有这把锁。</li></ul><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>java.lang.Object类提供了以下方法用于线程通信</p><ul><li>obj.wait() 执行该方法的线程释放obj的同步锁，并将该线程放入obj的等待池中</li><li>obj.notify() 执行该方法的线程随机唤醒obj等待池中的一个线程，将其放入锁池中</li><li>obj.notifyAll() 同上，将所有obj等待池中的线程放进锁池中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;同步代码块&quot;&gt;&lt;a href=&quot;#同步代码块&quot; class=&quot;headerlink&quot; title=&quot;同步代码块&quot;&gt;&lt;/a&gt;同步代码块&lt;/h2&gt;&lt;p&gt;使用 synchronized(obj){} 包住的代码块称为同步代码块&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-泛型</title>
    <link href="https://blog.forzgc.cn/2021/09/01/Java-%E6%B3%9B%E5%9E%8B/"/>
    <id>https://blog.forzgc.cn/2021/09/01/Java-%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-09-01T13:57:55.000Z</published>
    <updated>2021-10-03T15:26:22.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用泛型"><a href="#为什么要使用泛型" class="headerlink" title="为什么要使用泛型"></a>为什么要使用泛型</h2><p>泛型是为了参数化类型，而不必创建新的类型。</p><h2 id="泛型的三种使用方式"><a href="#泛型的三种使用方式" class="headerlink" title="泛型的三种使用方式"></a>泛型的三种使用方式</h2><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法</li></ul><span id="more"></span><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;</span><br><span class="line">  private 泛型标识 /*（成员变量类型）*/ var; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="line">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="line">public class Generic&lt;T&gt;&#123; </span><br><span class="line">    //key这个成员变量的类型为T,T的类型由外部指定  </span><br><span class="line">    private T key;</span><br><span class="line"></span><br><span class="line">    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span><br><span class="line">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span><br><span class="line">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</span><br><span class="line"></span><br><span class="line">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span><br><span class="line">Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());</span><br><span class="line">Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());</span><br></pre></td></tr></table></figure><p>在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。<br>如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p>注意：</p><ul><li>泛型的类型参数只能是类类型，不能是简单类型。</li><li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(ex_num instanceof Generic&lt;Number&gt;)&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//定义一个泛型接口</span><br><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    public T next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span><br><span class="line"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span><br><span class="line"> */</span><br><span class="line">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public T next() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 传入泛型实参时：</span><br><span class="line"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span><br><span class="line"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span><br><span class="line"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span><br><span class="line"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span><br><span class="line"> */</span><br><span class="line">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String next() &#123;</span><br><span class="line">        Random rand = new Random();</span><br><span class="line">        return fruits[rand.nextInt(3)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);</span><br><span class="line">Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </span><br><span class="line">// cannot be applied to Generic&lt;java.lang.Number&gt;</span><br><span class="line">// showKeyValue(gInteger);</span><br></pre></td></tr></table></figure><p>解决办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;</span><br><span class="line">    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符一般是使用 ? 代替具体的类型实参，注意了，此处 ? 是类型实参，而不是类型形参。<br>可以解决当具体类型不确定的时候，这个通配符就是 ?<br>当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表示未知类型。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型方法的基本介绍</span><br><span class="line"> * @param tClass 传入的泛型实参</span><br><span class="line"> * @return T 返回值为T类型</span><br><span class="line"> * 说明：</span><br><span class="line"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span><br><span class="line"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span><br><span class="line"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span><br><span class="line"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException, IllegalAccessException&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class GenericFruit &#123;</span><br><span class="line">    class Fruit&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;fruit&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Apple extends Fruit&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;apple&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Person&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Person&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class GenerateTest&lt;T&gt;&#123;</span><br><span class="line">        public void show_1(T t)&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span><br><span class="line">        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span><br><span class="line">        public &lt;E&gt; void show_3(E t)&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span><br><span class="line">        public &lt;T&gt; void show_2(T t)&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Apple apple = new Apple();</span><br><span class="line">        Person person = new Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        //apple是Fruit的子类，所以这里可以</span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span><br><span class="line">        //generateTest.show_1(person);</span><br><span class="line"></span><br><span class="line">        //使用这两个方法都可以成功</span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        //使用这两个方法也都可以成功</span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line">   //这个类是个泛型类，在上面已经介绍过</span><br><span class="line">   public class Generic&lt;T&gt;&#123;     </span><br><span class="line">        private T key;</span><br><span class="line"></span><br><span class="line">        public Generic(T key) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span><br><span class="line">        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span><br><span class="line">        //所以在这个方法中才可以继续使用 T 这个泛型。</span><br><span class="line">        public T getKey()&#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;</span><br><span class="line">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span><br><span class="line">        public E setKey(E key)&#123;</span><br><span class="line">             this.key = keu</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 这才是一个真正的泛型方法。</span><br><span class="line">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span><br><span class="line">     * 这个T可以出现在这个泛型方法的任意位置.</span><br><span class="line">     * 泛型的数量也可以为任意多个 </span><br><span class="line">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class="line">     *        ...</span><br><span class="line">     *        &#125;</span><br><span class="line">     */</span><br><span class="line">    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class="line">        System.out.println(&quot;container key :&quot; + container.getKey());</span><br><span class="line">        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        return test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span><br><span class="line">    public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;</span><br><span class="line">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span><br><span class="line">    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span><br><span class="line">    public void showKeyValue2(Generic&lt;?&gt; obj)&#123;</span><br><span class="line">        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">     * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot;</span><br><span class="line">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span><br><span class="line">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span><br><span class="line">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;  </span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;T&#x27; &quot;</span><br><span class="line">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span><br><span class="line">     * 所以这也不是一个正确的泛型方法声明。</span><br><span class="line">    public void showkey(T genericObj)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h3><p>通常可变参数只能为同一种类型，使用泛型后，可以传入不同类型的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void printMsg( T... args)&#123;</span><br><span class="line">    for(T t : args)&#123;</span><br><span class="line">        Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55);</span><br></pre></td></tr></table></figure><h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>静态方法中如果要用泛型，必须在方法上定义，不能使用泛型类声明的泛型，因为泛型类的泛型只针对实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StaticGenerator&lt;T&gt; &#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    /**</span><br><span class="line">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span><br><span class="line">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span><br><span class="line">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span><br><span class="line">          &quot;StaticGenerator cannot be refrenced from static context&quot;</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; void show(T t)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><p>上边界：<br>泛型通配符 ？extends XXX<br>泛型的声明 T extends XXX</p><p>下边界：<br>泛型通配符 ? super XXX</p><h2 id="本文来源"><a href="#本文来源" class="headerlink" title="本文来源"></a>本文来源</h2><p><a href="https://www.cnblogs.com/coprince/p/8603492.html">https://www.cnblogs.com/coprince/p/8603492.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么要使用泛型&quot;&gt;&lt;a href=&quot;#为什么要使用泛型&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用泛型&quot;&gt;&lt;/a&gt;为什么要使用泛型&lt;/h2&gt;&lt;p&gt;泛型是为了参数化类型，而不必创建新的类型。&lt;/p&gt;
&lt;h2 id=&quot;泛型的三种使用方式&quot;&gt;&lt;a href=&quot;#泛型的三种使用方式&quot; class=&quot;headerlink&quot; title=&quot;泛型的三种使用方式&quot;&gt;&lt;/a&gt;泛型的三种使用方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;泛型类&lt;/li&gt;
&lt;li&gt;泛型接口&lt;/li&gt;
&lt;li&gt;泛型方法&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-JDBC API</title>
    <link href="https://blog.forzgc.cn/2021/08/30/Java-JDBC-API/"/>
    <id>https://blog.forzgc.cn/2021/08/30/Java-JDBC-API/</id>
    <published>2021-08-30T14:02:43.000Z</published>
    <updated>2021-10-03T15:26:22.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口与类"><a href="#接口与类" class="headerlink" title="接口与类"></a>接口与类</h2><ul><li>Driver 接口和 DriverManager 类 负责驱动与驱动管理器</li><li>Connection 接口 负责数据库连接</li><li>Statement 接口 负责执行SQL语句</li><li>PreparedStatement 接口 负责执行SQL存储过程</li><li>ResultSet 接口 表示SQL查询语句返回结果集</li></ul><span id="more"></span><h2 id="Driver-接口和-DriverManager-类"><a href="#Driver-接口和-DriverManager-类" class="headerlink" title="Driver 接口和 DriverManager 类"></a>Driver 接口和 DriverManager 类</h2><p>所有JDBC驱动器都必须实现Driver接口<br>DriverManager类用来建立数据库连接，以及管理JDBC驱动器，有以下方法：</p><ul><li>registerDriver(Driver driver): 注册JDBC驱动器</li><li>getConnection(String url, String user, String pwd):建立数据库连接，并返回表示数据库连接的Connection对象</li></ul><h2 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a>Connection 接口</h2><p>Connection 接口有以下方法：</p><ul><li>createStatement(): 创建并返回Statement对象</li><li>prepareStatement(): 创建并返回PreparedStatement对象</li></ul><h2 id="Statement-接口"><a href="#Statement-接口" class="headerlink" title="Statement 接口"></a>Statement 接口</h2><p>Statement接口提供三个执行SQL语句的方法：</p><ul><li>execute(String sql): 执行各种SQL语句，该方法返回一个boolean类型的值，如果为true，表示所执行的SQL语句具有查询结果，可通过Statement的getResultSet()方法获得这一查询数据。</li><li>executeUpdate(String sql): 执行SQL语句的insert、update和delete语句。该方法返回一个int类型的值，表示数据库中受该SQL语句影响的记录的数目。</li><li>executeQuery(String sql): 执行SQL语句的select语句。该方法返回一个表示查询结果的ResultSet对象。</li></ul><h2 id="PreparedStatement-接口"><a href="#PreparedStatement-接口" class="headerlink" title="PreparedStatement 接口"></a>PreparedStatement 接口</h2><p>PreparedStatement 接口继承 Statement 接口，用来执行预准备的SQL语句。具有以下优点：</p><ul><li>简化程序代码</li><li>提高访问数据库的性能，因为只需要编译一次。</li></ul><p>PreparedStatement的使用步骤：</p><ol><li><p>通过Connection的prepareStatement()方法生成PreparedStatement对象，SQL语句中可被替换的值使用 ? 代替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement stmt = com.prepareStatement(&quot;select * from table where a = ? and b = ?&quot;)</span><br></pre></td></tr></table></figure></li><li><p>调用 PreparedStatement 的 setXXX() 方法，给参数赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stmt.setInt(1,10);</span><br><span class="line">stmt.setString(2,&quot;b&quot;);</span><br></pre></td></tr></table></figure></li><li><p>执行SQL语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = stmt.executeQuery();</span><br></pre></td></tr></table></figure></li></ol><h2 id="ResultSet-接口"><a href="#ResultSet-接口" class="headerlink" title="ResultSet 接口"></a>ResultSet 接口</h2><p>ResultSet 是执行select语句后得到的结果集。<br>结果集的行号从1开始，调用next()方法，可以将游标定位到下一条数据。<br>获取行数据使用getXXX()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getInt(int columnIndex)</span><br><span class="line">getInt(String columnName)</span><br><span class="line">getFloat(int columnIndex);</span><br><span class="line">getFloat(String columnName);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="JDBC-API的使用方法"><a href="#JDBC-API的使用方法" class="headerlink" title="JDBC API的使用方法"></a>JDBC API的使用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">    Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/xxx&quot;,&quot;root&quot;,&quot;12345678&quot;);</span><br><span class="line">    Statement statement = connection.createStatement();</span><br><span class="line">    ResultSet rs = statement.executeQuery(&quot;select * from xxx&quot;);</span><br><span class="line">    while (rs.next())&#123;</span><br><span class="line">        System.out.println(rs.getInt(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(ClassNotFoundException e)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;catch (SQLException e)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取新插入记录的主键"><a href="#获取新插入记录的主键" class="headerlink" title="获取新插入记录的主键"></a>获取新插入记录的主键</h2><ol><li>将表主键设置为 auto_increment类型</li><li>statement.executeUpdate(“insert xxx”,Statement.RETURN_GENERATED_KEYS)</li><li>statement.getGeneratedKeys()</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;接口与类&quot;&gt;&lt;a href=&quot;#接口与类&quot; class=&quot;headerlink&quot; title=&quot;接口与类&quot;&gt;&lt;/a&gt;接口与类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Driver 接口和 DriverManager 类 负责驱动与驱动管理器&lt;/li&gt;
&lt;li&gt;Connection 接口 负责数据库连接&lt;/li&gt;
&lt;li&gt;Statement 接口 负责执行SQL语句&lt;/li&gt;
&lt;li&gt;PreparedStatement 接口 负责执行SQL存储过程&lt;/li&gt;
&lt;li&gt;ResultSet 接口 表示SQL查询语句返回结果集&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-并发</title>
    <link href="https://blog.forzgc.cn/2021/08/22/Java-%E5%B9%B6%E5%8F%91/"/>
    <id>https://blog.forzgc.cn/2021/08/22/Java-%E5%B9%B6%E5%8F%91/</id>
    <published>2021-08-22T06:44:09.000Z</published>
    <updated>2021-10-03T15:26:22.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是指运行中的应用程序，每一个进程都有自己独立的内存空间。<br>每次使用java命令，就启动一个独立的Java虚拟机进程。<br>线程是指进程中的一个执行流程，一个进程可以同时执行多个不同的线程。<br>当进程中内多个线程同时运行时，这种运行方式称之为并发。<br>每次使用java命令启动一个Java虚拟机进程，都会创建一个main主线程。<br>创建线程有两种办法。</p><ul><li>拓展java.lang.Thread类</li><li>实现java.lang.Runnable接口</li></ul><span id="more"></span><p>Soldier类 继承 Thread类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Soldier extends Thread&#123;</span><br><span class="line">    public Soldier(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    public void fight()&#123;</span><br><span class="line">        for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            System.out.println(getName()+&quot;:打败第&quot;+i+&quot;个敌人&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        fight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fighter类 实现 Runnable接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Fighter implements Runnable&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Fighter(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void fight()&#123;</span><br><span class="line">        for(int i=0;i&lt;=10;i++)&#123;</span><br><span class="line">            System.out.println(name+&quot;:击毁第&quot;+i+&quot;驾战斗机&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        fight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>War类 运行自定义线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class War &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Soldier s1 = new Soldier(&quot;士兵1&quot;);</span><br><span class="line">        Soldier s2 = new Soldier(&quot;士兵2&quot;);</span><br><span class="line">        Soldier s3 = new Soldier(&quot;士兵3&quot;);</span><br><span class="line"></span><br><span class="line">        Fighter f1 = new Fighter(&quot;战机1&quot;);</span><br><span class="line">        Fighter f2 = new Fighter(&quot;战机2&quot;);</span><br><span class="line">        Fighter f3 = new Fighter(&quot;战机3&quot;);</span><br><span class="line">        Thread t1 = new Thread(f1);</span><br><span class="line">        Thread t2 = new Thread(f2);</span><br><span class="line">        Thread t3 = new Thread(f3);</span><br><span class="line"></span><br><span class="line">        s1.start();</span><br><span class="line">        s2.start();</span><br><span class="line">        s3.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ol><li>新建 new 创建Thread对象后，新建可以转为 就绪</li><li>就绪 Thread对象调用start()，等待cpu时，就绪可以转为 运行</li><li>运行 cpu执行时，运行可以转为 阻塞、等待、死亡</li><li>阻塞 因为某些原因（等待同步锁、执行sleep、发出io请求）放弃cpu，暂时停止运行，阻塞可以转为 就绪</li><li>等待 当线程执行某个对象的wait()方法或执行某个线程的join()方法，等待可以转化为阻塞</li><li>死亡 当执行完run()方法中的代码或遇到未捕获的异常时，就会退出run()方法，此时进入死亡状态，该线程结束生命周期。</li></ol><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级的取值范围为1-10。<br>Thread类有三个静态常量：</p><ul><li>MAX_PRIORITY :值为10</li><li>NORM_PRIORITY :值为5，默认值</li><li>MIN_PRIORITY :值为1</li></ul><p>获取和设置获取线程的优先级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread.getPriority()</span><br><span class="line">thread.setPriority(10)</span><br><span class="line">thread.setPriority(MAX_PRIORITY)</span><br></pre></td></tr></table></figure><p>线程优先级不能精确的控制线程的运行顺序。</p><h2 id="线程睡眠-Thread-sleep"><a href="#线程睡眠-Thread-sleep" class="headerlink" title="线程睡眠 Thread.sleep()"></a>线程睡眠 Thread.sleep()</h2><p>当执行 Thread.sleep(long millis)静态方法后 （当前线程）会转为阻塞状态。<br>当睡眠结束后线程会转为就绪状态。</p><p>改写Soldier类，加入线程睡眠，fight方法中的for循环体会在500毫秒睡眠后继续执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Soldier extends Thread&#123;</span><br><span class="line">    public Soldier(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    public void fight()&#123;</span><br><span class="line">        for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            System.out.println(getName()+&quot;:打败第&quot;+i+&quot;个敌人&quot;);</span><br><span class="line">            try&#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        fight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写War类，为主线程加入线程休眠</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class War &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Soldier s1 = new Soldier(&quot;士兵1&quot;);</span><br><span class="line">        Soldier s2 = new Soldier(&quot;士兵2&quot;);</span><br><span class="line">        Soldier s3 = new Soldier(&quot;士兵3&quot;);</span><br><span class="line"></span><br><span class="line">        s1.start(); // 注意这里</span><br><span class="line">        try&#123;</span><br><span class="line">            s1.sleep(10000);</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        s2.start();</span><br><span class="line">        s3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使是用s1调用sleep()，也是主线程休眠，因为sleep()方法是静态方法，与实例无关，只会将当前处于运行中的线程睡眠。</p><h2 id="线程让步-Thread-yield"><a href="#线程让步-Thread-yield" class="headerlink" title="线程让步 Thread.yield()"></a>线程让步 Thread.yield()</h2><p>当执行 Thread.yield() 后，如果有想同或者更高优先级的线程处于就绪状态，会将当前线程暂停转为就绪状态并执行其他相同或更高优先级的线程。</p><p>改写Soldier类，加入线程让步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Soldier extends Thread&#123;</span><br><span class="line">    public Soldier(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    public void fight()&#123;</span><br><span class="line">        for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            System.out.println(getName()+&quot;:打败第&quot;+i+&quot;个敌人&quot;);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        fight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行War类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class War &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Soldier s1 = new Soldier(&quot;士兵1&quot;);</span><br><span class="line">        Soldier s2 = new Soldier(&quot;士兵2&quot;);</span><br><span class="line">        Soldier s3 = new Soldier(&quot;士兵3&quot;);</span><br><span class="line"></span><br><span class="line">        s1.start();</span><br><span class="line">        s2.start();</span><br><span class="line">        s3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">士兵3:打败第1个敌人</span><br><span class="line">士兵1:打败第1个敌人</span><br><span class="line">士兵2:打败第1个敌人</span><br><span class="line">士兵3:打败第2个敌人</span><br><span class="line">士兵1:打败第2个敌人</span><br><span class="line">士兵2:打败第2个敌人</span><br><span class="line">士兵3:打败第3个敌人</span><br><span class="line">士兵1:打败第3个敌人</span><br><span class="line">士兵2:打败第3个敌人</span><br><span class="line">士兵3:打败第4个敌人</span><br><span class="line">士兵1:打败第4个敌人</span><br><span class="line">士兵2:打败第4个敌人</span><br><span class="line">士兵3:打败第5个敌人</span><br><span class="line">士兵1:打败第5个敌人</span><br><span class="line">士兵2:打败第5个敌人</span><br><span class="line">士兵3:打败第6个敌人</span><br><span class="line">士兵1:打败第6个敌人</span><br><span class="line">士兵2:打败第6个敌人</span><br><span class="line">士兵3:打败第7个敌人</span><br><span class="line">士兵1:打败第7个敌人</span><br><span class="line">士兵2:打败第7个敌人</span><br><span class="line">士兵3:打败第8个敌人</span><br><span class="line">士兵1:打败第8个敌人</span><br><span class="line">士兵2:打败第8个敌人</span><br><span class="line">士兵3:打败第9个敌人</span><br><span class="line">士兵1:打败第9个敌人</span><br><span class="line">士兵2:打败第9个敌人</span><br><span class="line">士兵3:打败第10个敌人</span><br><span class="line">士兵1:打败第10个敌人</span><br><span class="line">士兵2:打败第10个敌人</span><br></pre></td></tr></table></figure><p>Thread.sleep()和Thread.yield()都是静态方法，两种存在以下区别：</p><ul><li>Thread.yield()不会把运行机会交给低优先级的线程</li><li>Thread.sleep()执行后会进入阻塞状态，Thread.yield()会进入就绪状态</li><li>Thread.sleep()会抛出InterruptedException异常</li></ul><h2 id="等待其他现场结束-join"><a href="#等待其他现场结束-join" class="headerlink" title="等待其他现场结束 join()"></a>等待其他现场结束 join()</h2><p>当前运行线程中调用另一个线程的join()方法，当前运行线程就会转为阻塞状态，直到用一个线程结束，才会转为就绪状态。</p><p>改写War类，加入join()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class War &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;主线程开始&quot;);</span><br><span class="line">        Soldier s1 = new Soldier(&quot;士兵1&quot;);</span><br><span class="line">        s1.start();</span><br><span class="line">        try&#123;</span><br><span class="line">            s1.join();</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;主线程结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取当前线程的对象引用-Thread-currentThread"><a href="#获取当前线程的对象引用-Thread-currentThread" class="headerlink" title="获取当前线程的对象引用 Thread.currentThread()"></a>获取当前线程的对象引用 Thread.currentThread()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class CurrentThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    public CurrentThread(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for(int i = 0; i&lt;10 ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CurrentThread currentThread = new CurrentThread(&quot;current&quot;);</span><br><span class="line">        currentThread.start();</span><br><span class="line">        currentThread.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;p&gt;进程是指运行中的应用程序，每一个进程都有自己独立的内存空间。&lt;br&gt;每次使用java命令，就启动一个独立的Java虚拟机进程。&lt;br&gt;线程是指进程中的一个执行流程，一个进程可以同时执行多个不同的线程。&lt;br&gt;当进程中内多个线程同时运行时，这种运行方式称之为并发。&lt;br&gt;每次使用java命令启动一个Java虚拟机进程，都会创建一个main主线程。&lt;br&gt;创建线程有两种办法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拓展java.lang.Thread类&lt;/li&gt;
&lt;li&gt;实现java.lang.Runnable接口&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://blog.forzgc.cn/2021/08/21/Java-IO/"/>
    <id>https://blog.forzgc.cn/2021/08/21/Java-IO/</id>
    <published>2021-08-21T07:38:13.000Z</published>
    <updated>2021-10-03T15:26:22.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>字节输出流，抽象类<br><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/OutputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/OutputStream.html</a></p><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>文件字节输出流，OutputStream的子类<br><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/FileOutputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/FileOutputStream.html</a></p><h2 id="FilterOutputStream"><a href="#FilterOutputStream" class="headerlink" title="FilterOutputStream"></a>FilterOutputStream</h2><p>过滤字节输出流，OutputStream的子类<br>FilterOutputStream 类本身只是简单地重写那些将所有请求传递给所包含输出流的 OutputStream 的所有方法。<br>其有三个常用子类：BufferedOutputStream、DataOutputStream和PrintStream。</p><span id="more"></span><h2 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h2><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/BufferedOutputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/BufferedOutputStream.html</a></p><h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/DataOutputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/DataOutputStream.html</a></p><h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/PrintStream.html</a></p><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>字节输入流，抽象类<br><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/InputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/InputStream.html</a></p><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>文件字节输入流，InputStream的子类<br><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/FileInputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/FileInputStream.html</a></p><h2 id="FilterInputStream"><a href="#FilterInputStream" class="headerlink" title="FilterInputStream"></a>FilterInputStream</h2><p>过滤字节输入流，InputStream的子类。<br>FilterInputStream 类本身只是简单地重写那些将所有请求传递给所包含输入流的 InputStream 的所有方法。<br>其有两个常用子类：BufferedInputStream和DataInputStream。<br><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/FilterInputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/FilterInputStream.html</a></p><h2 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h2><p>BufferedInputStream 为另一个输入流添加一些功能，即缓冲输入以及支持 mark 和 reset 方法的能力。<br><a href="https://blog.csdn.net/dengjili/article/details/79416467">mark失效不仅需要超过readlimit，而且还需要达到缓冲区填满，才会失效。</a><br><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/BufferedInputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/BufferedInputStream.html</a></p><h2 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h2><p>数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。应用程序可以使用数据输出流写入稍后由数据输入流读取的数据。<br><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/DataInputStream.html">https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/DataInputStream.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;OutputStream&quot;&gt;&lt;a href=&quot;#OutputStream&quot; class=&quot;headerlink&quot; title=&quot;OutputStream&quot;&gt;&lt;/a&gt;OutputStream&lt;/h2&gt;&lt;p&gt;字节输出流，抽象类&lt;br&gt;&lt;a href=&quot;https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/OutputStream.html&quot;&gt;https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/OutputStream.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;FileOutputStream&quot;&gt;&lt;a href=&quot;#FileOutputStream&quot; class=&quot;headerlink&quot; title=&quot;FileOutputStream&quot;&gt;&lt;/a&gt;FileOutputStream&lt;/h2&gt;&lt;p&gt;文件字节输出流，OutputStream的子类&lt;br&gt;&lt;a href=&quot;https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/FileOutputStream.html&quot;&gt;https://tool.oschina.net/uploads/apidocs/jdk-zh/java/io/FileOutputStream.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;FilterOutputStream&quot;&gt;&lt;a href=&quot;#FilterOutputStream&quot; class=&quot;headerlink&quot; title=&quot;FilterOutputStream&quot;&gt;&lt;/a&gt;FilterOutputStream&lt;/h2&gt;&lt;p&gt;过滤字节输出流，OutputStream的子类&lt;br&gt;FilterOutputStream 类本身只是简单地重写那些将所有请求传递给所包含输出流的 OutputStream 的所有方法。&lt;br&gt;其有三个常用子类：BufferedOutputStream、DataOutputStream和PrintStream。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java 入门</title>
    <link href="https://blog.forzgc.cn/2021/07/20/Java-%E5%85%A5%E9%97%A8/"/>
    <id>https://blog.forzgc.cn/2021/07/20/Java-%E5%85%A5%E9%97%A8/</id>
    <published>2021-07-20T13:56:06.000Z</published>
    <updated>2021-10-03T15:26:22.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="main入口函数"><a href="#main入口函数" class="headerlink" title="main入口函数"></a>main入口函数</h2><p>main入口函数有以下要求：</p><ul><li>必须使用 public 修饰符</li><li>必须使用 static 修饰符</li><li>必须有一个String数组的参数</li><li>返回类型是void<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Java &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h2><p>java语言大小写敏感</p><h2 id="Java源文件结构"><a href="#Java源文件结构" class="headerlink" title="Java源文件结构"></a>Java源文件结构</h2><ul><li>零个或一个包声明</li><li>零个或多个包引入</li><li>零个或多个类声明</li></ul><p>包声明位于java文件代码顶部，一个java文件只能有一个包声明语句，如果没有声明，那么就在默认包中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p>如果一个Java源文件有多个类，那么最多只有一个类是public，并且这个类名称必须和源文件名称相同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;main入口函数&quot;&gt;&lt;a href=&quot;#main入口函数&quot; class=&quot;headerlink&quot; title=&quot;main入口函数&quot;&gt;&lt;/a&gt;main入口函数&lt;/h2&gt;&lt;p&gt;main入口函数有以下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须使用 public 修饰符&lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ES6-模块</title>
    <link href="https://blog.forzgc.cn/2021/07/18/ES6-%E6%A8%A1%E5%9D%97/"/>
    <id>https://blog.forzgc.cn/2021/07/18/ES6-%E6%A8%A1%E5%9D%97/</id>
    <published>2021-07-18T04:53:47.000Z</published>
    <updated>2021-10-03T15:26:22.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web环境使用模块的方法"><a href="#Web环境使用模块的方法" class="headerlink" title="Web环境使用模块的方法"></a>Web环境使用模块的方法</h2><p>script标签默认加载的是脚本，脚本会把代码放在一个环境中运行。<br>模块则会将不同模块的代码放在不同的环境中执行，每个模块文件的顶层this是undefined。<br>使用type=”module”可加载模块代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>使用关键字 export 可以将变量、函数或类导出。<br>导出时函数或类如果是非默认导出，都需要指定名称，不能是匿名的。<br>模块中未导出的变量、函数或类是不能在外部访问使用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line"></span><br><span class="line">// 导出声明/表达式</span><br><span class="line">export var a = &quot;a&quot;;</span><br><span class="line">export let b = &quot;b&quot;;</span><br><span class="line">export const c = &quot;c&quot;;</span><br><span class="line"></span><br><span class="line">export function sum(num1,num2)&#123;</span><br><span class="line">    return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line">export class People&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 未导出的声明，在模块外部无法访问使用</span><br><span class="line">var d = &quot;d&quot;;</span><br><span class="line"></span><br><span class="line">// 集中导出</span><br><span class="line">var e = &quot;e&quot;;</span><br><span class="line">var f = &quot;f&quot;;</span><br><span class="line">export &#123;</span><br><span class="line">    e,</span><br><span class="line">    f,</span><br><span class="line">&#125;</span><br><span class="line">var g = &quot;g&quot;;</span><br><span class="line">expoet g; // 错误写法，因为g不是引用值，只能通过&#123;g&#125;导出</span><br></pre></td></tr></table></figure><p>导出时重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;a&quot;;</span><br><span class="line">export &#123;a as b&#125;;</span><br></pre></td></tr></table></figure><p>导出默认值<br>一个模块只能导入一个默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export default 值/变量/函数/类</span><br><span class="line">export &#123;xxx as default&#125;</span><br></pre></td></tr></table></figure><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>使用关键字 import 可以导入模块的导出。<br>import 后面的大括号表示从模块导入的绑定（binding），from表示从哪个文件导入。<br>导入时需要指明模块文件的完整路径，包括格式后缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123;a,b,c,sum,People&#125; from &quot;./module.js&quot;;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(c);</span><br><span class="line">console.log(sum);</span><br><span class="line">console.log(People);</span><br></pre></td></tr></table></figure><p>导入时重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;a as A&#125; from &quot;./module.js&quot;;</span><br><span class="line">console.log(A);</span><br></pre></td></tr></table></figure><p>导入默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将默认值赋值给defalutValue</span><br><span class="line">import defalutValue from &quot;./module.js&quot;;</span><br><span class="line">import &#123;default as defalutValue&#125; from &quot;./module.js&quot;;</span><br><span class="line">// 导入默认值和非默认值可以写在一起</span><br><span class="line">import defalutValue,&#123;a,b&#125; from &quot;./module.js&quot;;</span><br><span class="line">import &#123;default as defalutValue,a,b&#125; from &quot;./module.js&quot;;</span><br></pre></td></tr></table></figure><p>导入模块的所有导出<br>用 (* as xxx) 可将所有导出封装成一个Module对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as moduleObj from &quot;./module.js&quot;</span><br><span class="line">console.log(moduleObj);</span><br></pre></td></tr></table></figure><p>导入的绑定（binding）不能被修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;a&#125; from &quot;./module.js&quot;;</span><br><span class="line">a = &quot;a1&quot;; // 报错</span><br></pre></td></tr></table></figure><p>不管模块被多少其他模块导入使用，模块只会被导入一次，所有导入它的模块使用的都是同一个被导入模块的实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// module1.js</span><br><span class="line">export var a = &quot;a&quot;;</span><br><span class="line">console.log(&quot;module1导出&quot;);</span><br><span class="line"></span><br><span class="line">// module2.js</span><br><span class="line">import &#123;a&#125; from &quot;./module1.js&quot;;</span><br><span class="line">console.log(&quot;module2导入module1&quot;);</span><br><span class="line">export var b = &quot;b&quot;;</span><br><span class="line">console.log(&quot;module2导出&quot;);</span><br><span class="line"></span><br><span class="line">// module.js</span><br><span class="line">import &#123;a&#125; from &quot;./module1.js&quot;</span><br><span class="line">import &#123;b&#125; from &quot;./module2.js&quot;</span><br><span class="line">console.log(&quot;module导入module1&quot;);</span><br><span class="line">console.log(&quot;module导入module2&quot;);</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">// module1导出</span><br><span class="line">// module2导入module1</span><br><span class="line">// module2导出</span><br><span class="line">// module导入module1</span><br><span class="line">// module导入module2</span><br></pre></td></tr></table></figure><h3 id="导出导入的绑定"><a href="#导出导入的绑定" class="headerlink" title="导出导入的绑定"></a>导出导入的绑定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; a &#125; from &quot;./module.js&quot;;</span><br><span class="line">export &#123; a &#125;;</span><br><span class="line">// 或者</span><br><span class="line">export &#123; a &#125; from &quot;./module.js&quot;;</span><br></pre></td></tr></table></figure><h2 id="无绑定导入"><a href="#无绑定导入" class="headerlink" title="无绑定导入"></a>无绑定导入</h2><p>如果导入的模块只修改作用域下的变量，比如Object、Array等，而不导出任何东西，那么可以进行无无绑定导入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// module1.js</span><br><span class="line">Array.prototype.pushAll = function(items)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">// module.js</span><br><span class="line">import &quot;./module1.js&quot;</span><br></pre></td></tr></table></figure><p>这个意味着，只要导入了模块，模块就可以对全局对象进行修改。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Web环境使用模块的方法&quot;&gt;&lt;a href=&quot;#Web环境使用模块的方法&quot; class=&quot;headerlink&quot; title=&quot;Web环境使用模块的方法&quot;&gt;&lt;/a&gt;Web环境使用模块的方法&lt;/h2&gt;&lt;p&gt;script标签默认加载的是脚本，脚本会把代码放在一个环境中运行。&lt;br&gt;模块则会将不同模块的代码放在不同的环境中执行，每个模块文件的顶层this是undefined。&lt;br&gt;使用type=”module”可加载模块代码&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&amp;quot;module&amp;quot; src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&amp;quot;module&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ES6-代理与反射</title>
    <link href="https://blog.forzgc.cn/2021/07/17/ES6-%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>https://blog.forzgc.cn/2021/07/17/ES6-%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2021-07-17T12:05:01.000Z</published>
    <updated>2021-10-03T15:26:22.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h2><p>创建代理需要传入需要代理的对象target和代理行为对象obj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const proxy = new Proxy(target,obj);</span><br></pre></td></tr></table></figure><h2 id="反射-Reflect"><a href="#反射-Reflect" class="headerlink" title="反射 Reflect"></a>反射 Reflect</h2><p>反射可以执行代理对象默认行为。代理和反射是一一对应关系，有代理就会有与之对应的反射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">    a:0,</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    get(trapTarget,key,receiver)&#123;</span><br><span class="line">        return Reflect.get(trapTarget,key,receiver) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(proxy.a); // 1</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="常见代理与反射"><a href="#常见代理与反射" class="headerlink" title="常见代理与反射"></a>常见代理与反射</h2><h3 id="set、get"><a href="#set、get" class="headerlink" title="set、get"></a>set、get</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    set(trapTarget,key,value,receiver)&#123;</span><br><span class="line">        return Reflect.set(trapTarget,key,value,receiver); // receiver使用代理的对象，下同</span><br><span class="line">    &#125;,</span><br><span class="line">    get(trapTarget,key,receiver)&#123;</span><br><span class="line">        return Reflect.get(trapTarget,key,receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p>代理in操作符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">    a:1,</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    has(trapTarget,key)&#123;</span><br><span class="line">        if(key==&quot;a&quot;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.has(trapTarget,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;a&quot; in target) // true</span><br><span class="line">console.log(&quot;a&quot; in proxy) // false</span><br></pre></td></tr></table></figure><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p>deleteProperty用于删除对象属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">    a:1,</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    deleteProperty(trapTarget,key)&#123;</span><br><span class="line">        if(key==&quot;a&quot;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.deleteProperty(trapTarget,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">delete proxy.a;</span><br><span class="line">console.log(proxy.a);</span><br></pre></td></tr></table></figure><h3 id="setPrototypeOf、getPrototypeOf"><a href="#setPrototypeOf、getPrototypeOf" class="headerlink" title="setPrototypeOf、getPrototypeOf"></a>setPrototypeOf、getPrototypeOf</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    setPrototypeOf(trapTarget,proto)&#123;</span><br><span class="line">        if(proto==null)&#123; // 不能设置为null</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.setPrototypeOf(trapTarget,proto);</span><br><span class="line">    &#125;,</span><br><span class="line">    getPrototypeOf(trapTarget)&#123;</span><br><span class="line">        return Reflect.getPrototypeOf(trapTarget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.setPrototypeOf(proxy,null); // 抛出错误</span><br><span class="line">Object.setPrototypeOf(proxy,&#123;&#125;);</span><br><span class="line">Object.getPrototypeOf(proxy); // &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="preventExtensions、isExtensible"><a href="#preventExtensions、isExtensible" class="headerlink" title="preventExtensions、isExtensible"></a>preventExtensions、isExtensible</h3><p>Object.preventExtensions() 用于禁用对象可拓展性，返回布尔值<br>Object.isExtensible() 可返回对象是否可拓展，返回布尔值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    preventExtensions(trapTarget)&#123;</span><br><span class="line">        return Reflect.preventExtensions(trapTarget);</span><br><span class="line">    &#125;,</span><br><span class="line">    isExtensible(trapTarget)&#123;</span><br><span class="line">        return Reflect.isExtensible(trapTarget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.preventExtensions(proxy);</span><br><span class="line">proxy.a = 1;</span><br><span class="line">console.log(Object.isExtensible(proxy)) // false</span><br><span class="line">console.log(proxy.a) // undefined</span><br></pre></td></tr></table></figure><h3 id="defineProperty、getOwnPropertyDescriptor"><a href="#defineProperty、getOwnPropertyDescriptor" class="headerlink" title="defineProperty、getOwnPropertyDescriptor"></a>defineProperty、getOwnPropertyDescriptor</h3><p>Object.defineProperty() 可以为对象定义属性以及属性描述符<br>Object.getOwnPropertyDescriptor() 获取对象属性描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    defineProperty(trapTarget,key,descriptor)&#123; // descriptor是属性描述对象</span><br><span class="line">        return Reflect.defineProperty(trapTarget,key,descriptor);</span><br><span class="line">    &#125;,</span><br><span class="line">    getOwnPropertyDescriptor(trapTarget,key)&#123;</span><br><span class="line">        return Reflect.getOwnPropertyDescriptor(trapTarget,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object.defineProperty(proxy,&quot;a&quot;,&#123;value:1&#125;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(proxy,&quot;a&quot;)); // &#123;value: 1, writable: false, enumerable: false, configurable: false&#125;</span><br></pre></td></tr></table></figure><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p>ownKeys可拦截对象自有属性，用于Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.assign() 四个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;a:1&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    ownKeys(trapTarget)&#123;</span><br><span class="line">        return Reflect.ownKeys(trapTarget);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">console.log(Object.keys(proxy)); // [&quot;a&quot;]</span><br></pre></td></tr></table></figure><h3 id="apply、construct"><a href="#apply、construct" class="headerlink" title="apply、construct"></a>apply、construct</h3><p>apply可拦截调用函数<br>construct可拦截new调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const target = function(a)&#123;this.a=a&#125;;</span><br><span class="line">const proxy = new Proxy(target,&#123;</span><br><span class="line">    apply(trapTarget,thisArg,argumentsList)&#123; // thisArg为this所指向的对象，argumentsList是参数数组</span><br><span class="line">        console.log(&quot;普通调用&quot;);</span><br><span class="line">        return Reflect.apply(trapTarget,thisArg,argumentsList);</span><br><span class="line">    &#125;,</span><br><span class="line">    construct(trapTarget,argumentsList)&#123;</span><br><span class="line">        console.log(&quot;new调用&quot;);</span><br><span class="line">        return Reflect.construct(trapTarget,argumentsList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">const targetObj = new proxy(1);</span><br><span class="line">console.log(targetObj.a); // 1</span><br><span class="line">proxy(1);</span><br><span class="line">console.log(window.a); // 1</span><br></pre></td></tr></table></figure><h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>使用Proxy.revocable()创建可撤销代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123;a:1&#125;;</span><br><span class="line">const &#123;proxy,revoke&#125; = Proxy.revocable(target,&#123;&#125;);</span><br><span class="line">console.log(proxy.a);</span><br><span class="line">revoke(); // 调用后代理将不可用</span><br><span class="line">console.log(proxy.a); // 抛出错误</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;代理-Proxy&quot;&gt;&lt;a href=&quot;#代理-Proxy&quot; class=&quot;headerlink&quot; title=&quot;代理 Proxy&quot;&gt;&lt;/a&gt;代理 Proxy&lt;/h2&gt;&lt;p&gt;创建代理需要传入需要代理的对象target和代理行为对象obj&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const proxy = new Proxy(target,obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;反射-Reflect&quot;&gt;&lt;a href=&quot;#反射-Reflect&quot; class=&quot;headerlink&quot; title=&quot;反射 Reflect&quot;&gt;&lt;/a&gt;反射 Reflect&lt;/h2&gt;&lt;p&gt;反射可以执行代理对象默认行为。代理和反射是一一对应关系，有代理就会有与之对应的反射。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const target = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a:0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const proxy = new Proxy(target,&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    get(trapTarget,key,receiver)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Reflect.get(trapTarget,key,receiver) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(proxy.a); // 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ES6 Promise总结</title>
    <link href="https://blog.forzgc.cn/2021/06/30/ES6-Promise%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.forzgc.cn/2021/06/30/ES6-Promise%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-30T14:05:08.000Z</published>
    <updated>2021-10-03T15:26:22.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h2><p>创建Promise时传入的函数会立即执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const p = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">console.log(2);</span><br><span class="line">// 先输出1</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="处理函数的执行"><a href="#处理函数的执行" class="headerlink" title="处理函数的执行"></a>处理函数的执行</h2><p>不管Promise对象什么时候绑定处理函数，只要Promise的状态已变化为完成或拒绝，对应的处理函数都会执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(()=&gt;&#123;</span><br><span class="line">    console.log(1); // 状态变化前已经绑定，状态变化后会执行</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    p.then(()=&gt;&#123;</span><br><span class="line">        console.log(1); // 状态变化后才绑定，依然会执行</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,3000)</span><br></pre></td></tr></table></figure><h2 id="已处理的Promise"><a href="#已处理的Promise" class="headerlink" title="已处理的Promise"></a>已处理的Promise</h2><p>可以通过 Promise.resolve()或Promise.reject() 分别创建已完成或已拒绝状态的Promise。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const p1 = Promise.resolve(); // fulfilled</span><br><span class="line">const p2 = Promise.reject();  // rejected</span><br></pre></td></tr></table></figure><p>Promise.resolve()方法可以传入一个Thenable对象，创建的Promise的状态由Thenable对象决定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const p3 = Promise.resolve(&#123;</span><br><span class="line">    then:function(resolve,reject)&#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// fulfilled</span><br><span class="line"></span><br><span class="line">const p4 = Promise.resolve(&#123;</span><br><span class="line">    then:function(resolve,reject)&#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// rejected</span><br></pre></td></tr></table></figure><p>Promise.resolve()可以传入一个Promise作为参数，不过这个Promise会被直接返回，不会再创建新的Promise。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const p1 = Promise.resolve();</span><br><span class="line">const p2 = Promise.resolve(p1);</span><br><span class="line">console.log(p1 == p2); // true</span><br></pre></td></tr></table></figure><h2 id="链式调用原理"><a href="#链式调用原理" class="headerlink" title="链式调用原理"></a>链式调用原理</h2><p>调用then()和catch()会返回一个新的Promise，这个Promise的状态有以下情况：</p><ol><li>Promise2=Promise1.then() 没有绑定对应处理函数，生成的Promise2和Promise1状态相同。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const p1 = Promise.resolve().then(); // fulfilled</span><br><span class="line">const p2 = Promise.reject().then(); // rejected</span><br></pre></td></tr></table></figure></li><li>Promise2=Promise1.then(func1,func2) 绑定了处理函数（没有抛出错误），Promise2的状态是已完成。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const p1 = Promise.resolve().then(()=&gt;&#123;&#125;); // fulfilled</span><br><span class="line">const p2 = Promise.reject().catch(()=&gt;&#123;&#125;); // fulfilled</span><br></pre></td></tr></table></figure></li><li>Promise2=Promise1.then(func,func) 绑定的函数func中抛出错误，Promise2的状态会是已拒绝。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const p1 = Promise.resolve().then(()=&gt;&#123;throw new Error(&quot;err&quot;)&#125;); // rejected</span><br><span class="line">const p2 = Promise.reject().catch(()=&gt;&#123;throw new Error(&quot;err&quot;)&#125;); // rejected</span><br></pre></td></tr></table></figure></li><li>Promise2=Promise1.then(func,func) 绑定的函数中返回了一个Promise3，Promise2会和Promise3状态相同，Promise3状态发生变化Promise2也会变化。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const p1 = Promise.resolve(); // fulfilled</span><br><span class="line">const p2 = Promise.reject(); // rejected</span><br><span class="line">const p3 = Promise.resolve().then(()=&gt;&#123;return p1&#125;); // fulfilled</span><br><span class="line">const p4 = Promise.resolve().then(()=&gt;&#123;return p2&#125;); // rejected</span><br><span class="line">const p5 = Promise.reject().catch(()=&gt;&#123;return p1&#125;); // fulfilled</span><br><span class="line">const p6 = Promise.reject().catch(()=&gt;&#123;return p2&#125;); // rejected</span><br><span class="line"></span><br><span class="line">const p7 = new Promise((resolve,reject)=&gt;&#123;setTimeout(()=&gt;&#123;resolve()&#125;,10000)&#125;);</span><br><span class="line">const p8 = Promise.resolve().then(()=&gt;&#123;return p7&#125;); // p8也会和p7一样在10秒后变为fulfilled</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;立即执行&quot;&gt;&lt;a href=&quot;#立即执行&quot; class=&quot;headerlink&quot; title=&quot;立即执行&quot;&gt;&lt;/a&gt;立即执行&lt;/h2&gt;&lt;p&gt;创建Promise时传入的函数会立即执行。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const p = new Promise(function(resolve,reject)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 先输出1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ES6 定型数组</title>
    <link href="https://blog.forzgc.cn/2021/06/28/ES6-%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.forzgc.cn/2021/06/28/ES6-%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84/</id>
    <published>2021-06-28T09:05:47.000Z</published>
    <updated>2021-10-03T15:26:22.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArrayBuffer数组缓冲区"><a href="#ArrayBuffer数组缓冲区" class="headerlink" title="ArrayBuffer数组缓冲区"></a>ArrayBuffer数组缓冲区</h2><p>数据缓冲区是一段包含特定数量的内存地址。可以通过new ArrayBuffer(n)创建一个数组缓冲区，创建的缓冲区长度是n个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(10);</span><br><span class="line">buffer.byteLength; // 10</span><br></pre></td></tr></table></figure><p>可以通过已有数组缓冲区实例的slice()方法截取创建一个新的实例，参数和数组的slice()方法相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const buffer1 = new ArrayBuffer(10);</span><br><span class="line">buffer1.byteLength; // 10</span><br><span class="line">const buffer2 = buffer1.slice(1,6);</span><br><span class="line">buffer1.byteLength; // 5</span><br></pre></td></tr></table></figure><p>数组缓冲区的大小在开始创建时已经确定，无法更改。</p><span id="more"></span><h2 id="DateView数据视图"><a href="#DateView数据视图" class="headerlink" title="DateView数据视图"></a>DateView数据视图</h2><p>视图是用来操作内存的接口，可以操作数组缓冲区或缓冲区字节的子集。DataView是一种通用的数组缓冲区视图，支持八种数值型数据类型。</p><ul><li>int8</li><li>uint8</li><li>int16</li><li>uint16</li><li>int32</li><li>uint32</li><li>float32</li><li>float64</li></ul><p>可以通过new DateView()，创建一个视图。第一个参数是一个数组缓冲区，第二个是字节偏移量（默认0），第三个是字节长度（默认数组缓冲区的字节长度-字节偏移量）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(10);</span><br><span class="line">const view1 = new DataView(buffer);</span><br><span class="line">console.log(view1.buffer == buffer); // true</span><br><span class="line">console.log(view1.byteOffset); // 0</span><br><span class="line">console.log(view1.byteLength); // 10</span><br><span class="line">const view2 = new DataView(buffer,1,6);</span><br><span class="line">console.log(view2.buffer == buffer); // true</span><br><span class="line">console.log(view2.byteOffset); // 1</span><br><span class="line">console.log(view2.byteLength); // 6</span><br></pre></td></tr></table></figure><p>DateView实例可以对数组缓冲区进行读取与写入。只需要调用实例的(get/set+上面罗列的8种数据类型名称)方法。比如：<br>getInt8(byteOffset,littleEndian)，第一个参数是字节偏移量，第二个是是否按小端序进行读取；<br>setInt8(byteOffset,value,littleEndian)，第一个参数是字节偏移量，第二个是写入的值，第三个是是否按小端序进行写入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(2);</span><br><span class="line">const view = new DataView(buffer);</span><br><span class="line">view.setInt8(0,5);</span><br><span class="line">view.setInt8(1,6);</span><br><span class="line">console.log(view.getInt8(0)); // 5</span><br><span class="line">console.log(view.getInt8(1)); // 6</span><br><span class="line">console.log(view.getInt16(0)); // 1286 可以使用getInt16方法读取两个字节的数据，同理init32是4个字节</span><br></pre></td></tr></table></figure><p>如果混用不同数据类型，DataView是一个完美的选择，因为它允许针对不同的数据类型，使用不同的方法对数组缓冲区进行读取和写入。</p><h2 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h2><p>定型数组是特定数据类型的视图，8种数值数据类型分别对应8种视图，还有一种特殊视图，分别是：</p><ul><li>Int8Array</li><li>Uint8Array</li><li>Uint8ClampedArray</li><li>Int16Array</li><li>Uint16Array</li><li>Int32Array</li><li>Uint32Array</li><li>Float32Array</li><li>Float64Array</li></ul><p>Uint8ClampedArray和Uint8Array大致相同，区别在于如果值小于0或大于255，Uint8ClampedArray分别转换为0或255。</p><p>创建定型数组的方法：</p><ol><li>传入ArrayBuffer实例、字节偏移量，字节长度，类似创建DataView<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const buffer = new ArrayBuffer(2);</span><br><span class="line">const view = new Int8Array(buffer,0,2);</span><br></pre></td></tr></table></figure></li><li>传入一个数字，这个数字表示定型数组元素的个数，这种方式会自动根据构造函数与传入的数字计算数组缓冲区大小然后创建数组缓冲区。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const view = new Int16Array(2);</span><br><span class="line">console.log(view.length); // 2</span><br><span class="line">console.log(view.byteLength); // 4</span><br></pre></td></tr></table></figure></li><li>传入一个定型数组，会将其每一项复制到新的定型数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const view1 = new Int16Array(2);</span><br><span class="line">view1[0]=1;</span><br><span class="line">view1[1]=1024;</span><br><span class="line">const view2 = new Int16Array(view1);</span><br><span class="line">const view3 = new Int8Array(view1);</span><br><span class="line">console.log(view2[0]); // 1</span><br><span class="line">console.log(view2[1]); // 1024</span><br><span class="line">console.log(view3[0]); // 1</span><br><span class="line">console.log(view3[1]); // 0  1024超出int8范围，所以赋值失败，默认0</span><br></pre></td></tr></table></figure></li><li>一个数组，如果所有元素不适合定型数据的类型，那么会抛出一个错误<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const view = new Int16Array([1,2,3]);</span><br><span class="line">console.log(view.length); // 3</span><br><span class="line">console.log(view.byteLength); // 6</span><br></pre></td></tr></table></figure></li><li>一个可迭代对象，同上</li><li>一个类数组对象，同上</li></ol><p>定型数组构造函数或实例上有一个BYTES_PER_ELEMENT属性，表示每个元素占用字节大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Int8Array.BYTES_PER_ELEMENT); // 1</span><br><span class="line">console.log(Int16Array.BYTES_PER_ELEMENT); // 2</span><br><span class="line">console.log(Int32Array.BYTES_PER_ELEMENT); // 4</span><br></pre></td></tr></table></figure><h2 id="定型数组与数组的异同"><a href="#定型数组与数组的异同" class="headerlink" title="定型数组与数组的异同"></a>定型数组与数组的异同</h2><ol><li>定型数组不是普通数组，它不继承自Array。</li><li>定型数组和数组一样都可以使用索引值的方式读取和写入值。</li><li>定型数组的length属性为不可写属性，无法修改。如果在严格模式下修改会报错。</li><li>数组可以通过不存在的索引来改变数组的长度，但定型数组长度不能更改。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr = new Array(1,2,3);</span><br><span class="line">const view = new Int8Array([1,2,3]);</span><br><span class="line">arr[3] = 4;</span><br><span class="line">console.log(arr.length); // 4</span><br><span class="line">view[3] = 4;</span><br><span class="line">console.log(view.length); // 3</span><br></pre></td></tr></table></figure></li><li>与数组有很多相同的方法：copyWithin() entries() fill() filter() find() findIndex() forEach() indexOf() join() keys() lastIndexOf() map() reduce() reduceRight() reverse() slice() sort() values() 。不同的地方是，定型数组会检查数值类型是否安全，如果不安全，会使用0替代。</li><li>定型数组也可以使用of()和from()方法构建实例。</li><li>定型数组缺失的数组方法：concat() pop() push() shift() unshift() splice() ，这些方法用于连接数组或者会改变length，这是定型数组不允许的。</li><li>定型数组特有的方法：set() subarray() 。set()方法用于复制其他数组（数组或定型数组都可以）的值到当前数组。subarray()方法则用于提取生成一个新的定型数组，它与slice()方法的区别是slice()方法会创建新的ArrayBuffer，subarray()方法共用ArrayBuffer。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const view = new Int8Array([1,2,3]);</span><br><span class="line">view.set([4,5,6]); // 第一个参数是被复制的数组或定型数组</span><br><span class="line">console.log(view); // Int8Array [4,5,6]</span><br><span class="line">view.set([7,8],1); // 第二个参数是开始复制的索引值</span><br><span class="line">console.log(view); // Int8Array [4,7,8]</span><br><span class="line"></span><br><span class="line">const view1 = view.subarray();</span><br><span class="line">console.log(view1); // Int8Array [4,7,8]</span><br><span class="line">const view2 = view.subarray(1); // 第一个参数表示起始索引值</span><br><span class="line">console.log(view2); // Int8Array [7,8]</span><br><span class="line">const view3 = view.subarray(1,2); // 第二个参数表示结束索引值（不包含）</span><br><span class="line">console.log(view3); // Int8Array [7]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ArrayBuffer数组缓冲区&quot;&gt;&lt;a href=&quot;#ArrayBuffer数组缓冲区&quot; class=&quot;headerlink&quot; title=&quot;ArrayBuffer数组缓冲区&quot;&gt;&lt;/a&gt;ArrayBuffer数组缓冲区&lt;/h2&gt;&lt;p&gt;数据缓冲区是一段包含特定数量的内存地址。可以通过new ArrayBuffer(n)创建一个数组缓冲区，创建的缓冲区长度是n个字节。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const buffer = new ArrayBuffer(10);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buffer.byteLength; // 10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以通过已有数组缓冲区实例的slice()方法截取创建一个新的实例，参数和数组的slice()方法相同。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const buffer1 = new ArrayBuffer(10);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buffer1.byteLength; // 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const buffer2 = buffer1.slice(1,6);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buffer1.byteLength; // 5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数组缓冲区的大小在开始创建时已经确定，无法更改。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ES6 数组</title>
    <link href="https://blog.forzgc.cn/2021/06/27/ES6-%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.forzgc.cn/2021/06/27/ES6-%E6%95%B0%E7%BB%84/</id>
    <published>2021-06-27T13:33:46.000Z</published>
    <updated>2021-10-03T15:26:22.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p>Array.of()方法可以规避new Array()的歧义，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = new Array(6);</span><br><span class="line">console.log(arr.length); // 6</span><br><span class="line">console.log(arr[0]); // undefined</span><br></pre></td></tr></table></figure><p>new Array()如果传入一个整数作为参数，那么创建的是一个长度为数字的空数组。<br>而Array.of()不管传入一个整数还是别的参数，都会生成包含传入参数的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = Array.of(6);</span><br><span class="line">const arr2 = Array.of(6,7,8);</span><br><span class="line">console.log(arr1.length); // 1</span><br><span class="line">console.log(arr1[0]); // 6</span><br><span class="line">console.log(arr2.length); // 3</span><br><span class="line">console.log(arr2[0]); // 6</span><br></pre></td></tr></table></figure><p>所以在创建数组时，如果可能只有一个数值型参数，那么应该使用Array.of()，而不是new Array()。<br>Array.of()不使用Symbol.species确定返回类型，而是this，即返回类型和构造函数相同，不能自定义。</p><span id="more"></span><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>Array.from()方法可以接受可迭代对象（有Symbol.iterator属性的对象）或类数组（arguments,NodeList等）作为第一个参数，最终返回一个数组。<br>还可以接受一个映射函数作为第二个参数，如果映射函数中使用到this，可以将this所指代的对象作为第三个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Add&#123;</span><br><span class="line">    constructor(value)&#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    calc(originValue)&#123;</span><br><span class="line">        return originValue + this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const add1 = new Add(1);</span><br><span class="line">function translate()&#123;</span><br><span class="line">    return Array.from(arguments,add1.calc,add1);</span><br><span class="line">&#125;</span><br><span class="line">translate(1,2,3); // [2,3,4]</span><br></pre></td></tr></table></figure><p>Array.from() 不使用Symbol.species确定返回类型，同Array.of()。</p><h3 id="find-和findIndex"><a href="#find-和findIndex" class="headerlink" title="find()和findIndex()"></a>find()和findIndex()</h3><p>find()方法用于查找数组中的值，第一个参数是一个查找回调函数，第二个参数可传入回调函数中this指向的对象。<br>findIndex()方法和find类似，不过返回的是值的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1,2,3,4,5,6];</span><br><span class="line">numbers.find(x=&gt;x&gt;4); // 5</span><br><span class="line">numbers.findIndex(x=&gt;x&gt;4); // 4</span><br></pre></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>fill()方法可以使用指定的值填充数组。第一个参数是填充的值，第二个参数是填充的开始索引（默认0），第三个参数是结束索引（不包含，默认数组长度）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1,2,3,4,5,6];</span><br><span class="line">numbers.fill(0,2,4); // [1,2,0,0,5,6]</span><br></pre></td></tr></table></figure><p>当开始索引或结束索引为负值时，那么会使用length+索引值作为参数。</p><h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><p>copyWithin()方法和fill()方法类似，不过填充的值不是特定的，而是数组中已存在的。<br>第一个参数是填充开始的索引位置，第二个参数是获取填充值的开始索引位置（默认0），第三个是获取填充值的结束位置（不包含，默认数组长度）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1,2,3,4,5,6];</span><br><span class="line">// numbers.copyWithin(3,0); // [1,2,3,1,2,3]</span><br><span class="line">// numbers.copyWithin(0,3); // [4,5,6,4,5,6]</span><br><span class="line">// numbers.copyWithin(0,1); // [2,3,4,5,6,6]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Array-of&quot;&gt;&lt;a href=&quot;#Array-of&quot; class=&quot;headerlink&quot; title=&quot;Array.of()&quot;&gt;&lt;/a&gt;Array.of()&lt;/h3&gt;&lt;p&gt;Array.of()方法可以规避new Array()的歧义，比如&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const arr = new Array(6);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(arr.length); // 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(arr[0]); // undefined&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;new Array()如果传入一个整数作为参数，那么创建的是一个长度为数字的空数组。&lt;br&gt;而Array.of()不管传入一个整数还是别的参数，都会生成包含传入参数的数组。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const arr1 = Array.of(6);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const arr2 = Array.of(6,7,8);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(arr1.length); // 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(arr1[0]); // 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(arr2.length); // 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(arr2[0]); // 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以在创建数组时，如果可能只有一个数值型参数，那么应该使用Array.of()，而不是new Array()。&lt;br&gt;Array.of()不使用Symbol.species确定返回类型，而是this，即返回类型和构造函数相同，不能自定义。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ES6 类</title>
    <link href="https://blog.forzgc.cn/2021/06/22/ES6-%E7%B1%BB/"/>
    <id>https://blog.forzgc.cn/2021/06/22/ES6-%E7%B1%BB/</id>
    <published>2021-06-22T13:38:07.000Z</published>
    <updated>2021-10-03T15:26:22.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ClassName&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    func1()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    func2()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的声明实际上是构造函数的语法糖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeOf(ClassName)=&quot;function&quot;</span><br></pre></td></tr></table></figure><span id="more"></span><p>与函数不同的是类的的原型（Class.prototype）不可修改,与函数相比，类还有如下特点：</p><ul><li>类的声明不会被提升</li><li>类声明中的代码自动运行在严格模式下</li><li>类中的所有方法是不可枚举的，二函数需要使用Object.defineProperty()设置</li><li>类只能通过new调用，其他方式会报错</li><li>在类中修改类名会报错</li><li>通过类声明的对象的属性中只有constructor方法可以用new调用。</li></ul><h1 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h1><p>基本的类表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let Class1 = class&#123;...&#125;</span><br></pre></td></tr></table></figure><p>可以在class后添加一个标识符即可定义为命名类表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let Class1 = class Class2&#123;...&#125;</span><br><span class="line">// 此时Class2作为标识符只能在类中使用，不能在类的外部使用（函数表达式同理）</span><br></pre></td></tr></table></figure><h3 id="类是一等公民"><a href="#类是一等公民" class="headerlink" title="类是一等公民"></a>类是一等公民</h3><p>JavaScript的一等公民是指可以传入函数，可以从函数中返回，并且可以赋值给变量的值。<br>即类可以作为值参与函数的传参与赋值。</p><h3 id="类的访问器属性"><a href="#类的访问器属性" class="headerlink" title="类的访问器属性"></a>类的访问器属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Class1&#123;</span><br><span class="line">    constructor(classValue)&#123;</span><br><span class="line">        this._classValue=classValue;</span><br><span class="line">    &#125;</span><br><span class="line">    set classValue(value)&#123;</span><br><span class="line">        this._classValue=value</span><br><span class="line">    &#125;</span><br><span class="line">    get classValue()&#123;</span><br><span class="line">        return this._classValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// classValue 将被定义在类的原型上，即 Class1.prototype</span><br></pre></td></tr></table></figure><h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>类中可以使用可计算属性为类添加方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Class1&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    [methodName]()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><p>可以在类中定义生成器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    *createIterator()&#123;</span><br><span class="line">        yield 1;</span><br><span class="line">        yield 2;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接为类定义默认迭代器（的生成器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.items = [1,2,3];</span><br><span class="line">    &#125;</span><br><span class="line">    *[Symbol.iterator]()&#123;</span><br><span class="line">        yield *this.items.values()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myClass = new MyClass();</span><br><span class="line">for(const x of myClass)&#123;</span><br><span class="line">    console.log(x) // 1 2 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>可以用static为类添加静态成员，即不会出现在实例化对象原型上的属性，这个属性只能通过类来使用。静态成员可被继承。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass()&#123;</span><br><span class="line">    consttuctor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    static create(name)&#123;</span><br><span class="line">        return new MyClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员的ES5写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function MyType(name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">MyType.create=function(name)&#123;</span><br><span class="line">    return new MyType(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的所有方法和访问器属性都可以用static关键字，除了constructors</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    constructor(num)&#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    addOne()&#123;</span><br><span class="line">        retuen this.num + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyClass1 extends MyClass&#123;</span><br><span class="line">    constructor(num)&#123;</span><br><span class="line">        super(num);</span><br><span class="line">    &#125;</span><br><span class="line">    subOne()&#123;</span><br><span class="line">        return this.num - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不写派生类的constructor，那默认constructor的内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(...args)&#123;</span><br><span class="line">    super(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承的ES5写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function MyType(num)&#123;</span><br><span class="line">    this.num = num;</span><br><span class="line">&#125;</span><br><span class="line">MyType.prototype.add=function()&#123;</span><br><span class="line">    return this.num + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用MyType，将this传入</span><br><span class="line">function MyType1(num)&#123;</span><br><span class="line">    MyType.call(this,num)</span><br><span class="line">&#125;</span><br><span class="line">// 以MyType的原型创建MyType1的原型，并修改其constructor</span><br><span class="line">MyType1.prototype = Object.create(MyType.prototype,&#123;</span><br><span class="line">    constructor:&#123;</span><br><span class="line">        value:MyType1,</span><br><span class="line">        enumerable:true,</span><br><span class="line">        writable:true,</span><br><span class="line">        configurable:true,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">MyType.prototype.sub=function()&#123;</span><br><span class="line">    return this.num - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中使用this，需先调用super。<br>extends后可以是表达式，表达式的结果必须是一个函数，并且函数有constructor属性和原型。</p><h3 id="继承-ES5和ES6的区别"><a href="#继承-ES5和ES6的区别" class="headerlink" title="继承 ES5和ES6的区别"></a>继承 ES5和ES6的区别</h3><p>ES5先用派生类创建对象，然后将基类的方法给到这个对象。<br>ES6则是先用基类创建对象，然后再将this指向这个对象。</p><h3 id="Symbol-species-属性"><a href="#Symbol-species-属性" class="headerlink" title="Symbol.species 属性"></a>Symbol.species 属性</h3><p>以下内建类型定义了Symbol.species属性。</p><ul><li>Array</li><li>ArrayBuffer</li><li>Map</li><li>Promise</li><li>RegExp</li><li>Set</li><li>Typed arrays</li></ul><p>Symbol.species属性是一个静态访问器属性（只有get），它返回一个构造函数。<br>每当实例的方法需要创建类的实例时，必须使用它返回的构造函数。<br>通常Symbol.species属性返回的是this，即构造函数本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyArray extends Array&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const instance1 = new MyArray(1,2,3);</span><br><span class="line">const instance2 = instance1.slice(1,2);</span><br><span class="line">console.log(instance2 instance MyArray); // true</span><br></pre></td></tr></table></figure><p>上面slice是继承Array得来的方法，调用它得到的结果却是MyArray的实例。<br>是因为slice方法在构建实例时，使用了Symbol.species返回的构造函数，即MyArray。</p><p>自定义类的类似写法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&#123;</span><br><span class="line">    constructor(value)&#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    static get [Symbol.species]()&#123;</span><br><span class="line">        return this; // 这里的this指当前调用这个属性的类，不一定是MyClass，也可以是MyClass的子类。</span><br><span class="line">    &#125;</span><br><span class="line">    clone()&#123;</span><br><span class="line">        return new this.constructor[Symbol.species](this.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyClass1 extends MyClass&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const instance1 = new MyClass1(&quot;a&quot;).clone();</span><br><span class="line">console.log(instance1 instance MyClass1); // true 通过Symbol.species就可以做到‘子类的实例’调用‘继承的来的方法’获得‘子类实例’的功能</span><br><span class="line">console.log(instance1 instance MyClass); // true</span><br></pre></td></tr></table></figure><p>可以自定义Symbol.species属性返回的构造函数，达到改变通过实例的方法创建的实例类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyClass1 extends MyClass&#123;</span><br><span class="line">    static get [Symbol.species]()&#123;</span><br><span class="line">        return MyClass; // 改为MyClass，那么MyClass1的实例调用clone创建的是MyClass实例。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;类的声明&quot;&gt;&lt;a href=&quot;#类的声明&quot; class=&quot;headerlink&quot; title=&quot;类的声明&quot;&gt;&lt;/a&gt;类的声明&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class ClassName&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    constructor()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func1()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func2()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类的声明实际上是构造函数的语法糖&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typeOf(ClassName)=&amp;quot;function&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>阿里云安装Archlinux</title>
    <link href="https://blog.forzgc.cn/2021/06/19/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85Archlinux/"/>
    <id>https://blog.forzgc.cn/2021/06/19/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85Archlinux/</id>
    <published>2021-06-19T12:27:10.000Z</published>
    <updated>2021-10-03T15:26:22.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载Archlinux"><a href="#下载Archlinux" class="headerlink" title="下载Archlinux"></a>下载Archlinux</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-2021.06.01-x86_64.iso</span><br><span class="line">mv arch* arch.iso</span><br></pre></td></tr></table></figure><h3 id="创建相关文件夹"><a href="#创建相关文件夹" class="headerlink" title="创建相关文件夹"></a>创建相关文件夹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tempfs</span><br><span class="line">mount tmpfs /tmpfs -t tmpfs -o size=1G</span><br><span class="line">mkdir /tmpfs/iso</span><br><span class="line">mkdir /tmpfs/sfs</span><br><span class="line">mkdir /tmpfs/space</span><br><span class="line">mkdir /tmpfs/work</span><br><span class="line">cd /tempfs</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="挂载live系统文件"><a href="#挂载live系统文件" class="headerlink" title="挂载live系统文件"></a>挂载live系统文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount ~/arch.iso iso</span><br><span class="line">cp iso/arch/x86_64/airootfs.sfs ./</span><br><span class="line">umount iso</span><br><span class="line">mount airootfs.sfs sfs</span><br></pre></td></tr></table></figure><h3 id="拓展live系统空间"><a href="#拓展live系统空间" class="headerlink" title="拓展live系统空间"></a>拓展live系统空间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount overlay work -t overlay -o lowerdir=sfs,upperdir=space,workdir=work</span><br></pre></td></tr></table></figure><h3 id="进入live系统"><a href="#进入live系统" class="headerlink" title="进入live系统"></a>进入live系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp work/usr/bin/arch-chroot ./</span><br><span class="line">./arch-chroot work</span><br><span class="line">mount /dev/vda1 /mnt</span><br><span class="line">cd /mnt</span><br><span class="line">rm -rf *</span><br><span class="line">cd /</span><br></pre></td></tr></table></figure><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman-key --init</span><br><span class="line">pacman-key --populate archlinux</span><br></pre></td></tr></table></figure><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>接下来的可参考腾讯云安装的步骤<a href="https://blog.forzgc.cn/2021/06/15/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%AE%89%E8%A3%85Archlinux/">腾讯云安装Archlinux</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;下载Archlinux&quot;&gt;&lt;a href=&quot;#下载Archlinux&quot; class=&quot;headerlink&quot; title=&quot;下载Archlinux&quot;&gt;&lt;/a&gt;下载Archlinux&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-2021.06.01-x86_64.iso&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv arch* arch.iso&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;创建相关文件夹&quot;&gt;&lt;a href=&quot;#创建相关文件夹&quot; class=&quot;headerlink&quot; title=&quot;创建相关文件夹&quot;&gt;&lt;/a&gt;创建相关文件夹&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir /tempfs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mount tmpfs /tmpfs -t tmpfs -o size=1G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir /tmpfs/iso&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir /tmpfs/sfs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir /tmpfs/space&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir /tmpfs/work&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd /tempfs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mac终端ssh超时断开的解决方法</title>
    <link href="https://blog.forzgc.cn/2021/06/19/mac%E7%BB%88%E7%AB%AFssh%E8%B6%85%E6%97%B6%E6%96%AD%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.forzgc.cn/2021/06/19/mac%E7%BB%88%E7%AB%AFssh%E8%B6%85%E6%97%B6%E6%96%AD%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2021-06-19T12:22:56.000Z</published>
    <updated>2021-10-03T15:26:22.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/ssh_config</span><br><span class="line"># 添加</span><br><span class="line">ServerAliveCountMax 3</span><br><span class="line">ServerAliveInterval 60</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;修改配置文件&quot;&gt;&lt;a href=&quot;#修改配置文件&quot; class=&quot;headerlink&quot; title=&quot;修改配置文件&quot;&gt;&lt;/a&gt;修改配置文件&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
  </entry>
  
</feed>
